{
  "version": 3,
  "sources": ["../../ol/source/VectorTile.js"],
  "sourcesContent": ["/**\n * @module ol/source/VectorTile\n */\n\nimport TileState from '../TileState.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport Tile from '../VectorTile.js';\nimport {assert} from '../asserts.js';\nimport EventType from '../events/EventType.js';\nimport {\n  buffer as bufferExtent,\n  getIntersection,\n  intersects,\n} from '../extent.js';\nimport {loadFeaturesXhr} from '../featureloader.js';\nimport {isEmpty} from '../obj.js';\nimport {equivalent} from '../proj.js';\nimport {toSize} from '../size.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM} from '../tilegrid/common.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport UrlTile from './UrlTile.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options<FeatureType>} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n\n    const extent = options.extent || extentFromProjection(projection);\n\n    const tileGrid =\n      options.tileGrid ||\n      createXYZ({\n        extent: extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize || 512,\n      });\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n     * @type {Object<string, Array<string>>}\n     * @private\n     */\n    this.tileKeysBySourceTileUrl_ = {};\n\n    /**\n     @type {Object<string, Tile<FeatureType>>}\n     */\n    this.sourceTiles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector render tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  getSourceTiles(pixelRatio, projection, tile) {\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      const urlTileCoord = tile.wrappedTileCoord;\n      const tileGrid = this.getTileGridForProjection(projection);\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const z = urlTileCoord[0];\n      const resolution = tileGrid.getResolution(z);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(extent, -resolution, extent);\n      const sourceTileGrid = this.tileGrid;\n      const sourceExtent = sourceTileGrid.getExtent();\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      const sourceZ = sourceTileGrid.getZForResolution(\n        resolution,\n        this.zDirection,\n      );\n\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        const tileUrl = this.tileUrlFunction(\n          sourceTileCoord,\n          pixelRatio,\n          projection,\n        );\n        if (!this.sourceTiles_[tileUrl]) {\n          this.sourceTiles_[tileUrl] = new this.tileClass(\n            sourceTileCoord,\n            tileUrl ? TileState.IDLE : TileState.EMPTY,\n            tileUrl,\n            this.format_,\n            this.tileLoadFunction,\n          );\n        }\n        const sourceTile = this.sourceTiles_[tileUrl];\n        tile.sourceTiles.push(sourceTile);\n        if (!this.tileKeysBySourceTileUrl_[tileUrl]) {\n          this.tileKeysBySourceTileUrl_[tileUrl] = [];\n        }\n        this.tileKeysBySourceTileUrl_[tileUrl].push(tile.getKey());\n        const sourceTileState = sourceTile.getState();\n        if (sourceTileState < TileState.LOADED) {\n          const listenChange = (event) => {\n            this.handleTileChange(event);\n            const state = sourceTile.getState();\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              const sourceTileKey = sourceTile.getKey();\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n              }\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(\n                  isEmpty(tile.errorTileKeys)\n                    ? TileState.LOADED\n                    : TileState.ERROR,\n                );\n              }\n            }\n          };\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\n          tile.loadingSourceTiles++;\n        }\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent =\n            sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid.getResolution(\n            sourceTileCoord[0],\n          );\n          sourceTile.load();\n        }\n      });\n      if (!tile.loadingSourceTiles) {\n        tile.setState(\n          tile.sourceTiles.some(\n            (sourceTile) => sourceTile.getState() === TileState.ERROR,\n          )\n            ? TileState.ERROR\n            : TileState.LOADED,\n        );\n      }\n    }\n\n    return tile.sourceTiles;\n  }\n\n  /**\n   * @param {VectorRenderTile} tile Vector render tile.\n   */\n  removeSourceTiles(tile) {\n    const tileKey = tile.getKey();\n    const sourceTiles = tile.sourceTiles;\n    for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n      const sourceTileUrl = sourceTiles[i].getTileUrl();\n      if (!this.tileKeysBySourceTileUrl_[sourceTileUrl]) {\n        return;\n      }\n      const index =\n        this.tileKeysBySourceTileUrl_[sourceTileUrl].indexOf(tileKey);\n      if (index === -1) {\n        continue;\n      }\n      this.tileKeysBySourceTileUrl_[sourceTileUrl].splice(index, 1);\n      if (this.tileKeysBySourceTileUrl_[sourceTileUrl].length === 0) {\n        delete this.tileKeysBySourceTileUrl_[sourceTileUrl];\n        delete this.sourceTiles_[sourceTileUrl];\n      }\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const sourceExtent = this.getTileGrid().getExtent();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    let empty = true;\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        empty =\n          empty &&\n          !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      });\n    }\n    const newTile = new VectorRenderTile(\n      tileCoord,\n      empty ? TileState.EMPTY : TileState.IDLE,\n      urlTileCoord,\n      this.getSourceTiles.bind(this, pixelRatio, projection),\n      this.removeSourceTiles.bind(this),\n    );\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      const sourceProjection = this.getProjection();\n      assert(\n        sourceProjection === null || equivalent(sourceProjection, projection),\n        'A VectorTile source can only be rendered if it has a projection compatible with the view projection.',\n      );\n\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      const resolutions = sourceTileGrid.getResolutions().slice();\n      const origins = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getOrigin(z);\n      });\n      const tileSizes = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getTileSize(z);\n      });\n      const length = DEFAULT_MAX_ZOOM + 1;\n      for (let z = resolutions.length; z < length; ++z) {\n        resolutions.push(resolutions[z - 1] / 2);\n        origins.push(origins[z - 1]);\n        tileSizes.push(tileSizes[z - 1]);\n      }\n      tileGrid = new TileGrid({\n        extent: sourceTileGrid.getExtent(),\n        origins: origins,\n        resolutions: resolutions,\n        tileSizes: tileSizes,\n      });\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   * @override\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   * @override\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [\n      Math.round(tileSize[0] * pixelRatio),\n      Math.round(tileSize[1] * pixelRatio),\n    ];\n  }\n\n  /**\n   * @param {boolean} overlaps The source has overlapping geometries.\n   */\n  setOverlaps(overlaps) {\n    this.overlaps_ = overlaps;\n    this.changed();\n  }\n}\n\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @param {import(\"../VectorTile.js\").default<FeatureType>} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n      loadFeaturesXhr(\n        url,\n        tile.getFormat(),\n        extent,\n        resolution,\n        projection,\n        tile.onLoad.bind(tile),\n        tile.onError.bind(tile),\n      );\n    },\n  );\n}\n"],
  "mappings": "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",
  "names": ["VectorTile_default"]
}
