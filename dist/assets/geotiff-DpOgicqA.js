const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/raw-Cnb_Ypsi.js","assets/index-C_ldSz15.js","assets/index-BbS-toGA.css","assets/lzw-DOH9cVIV.js","assets/jpeg-DWrTXVOr.js","assets/deflate-YOpszOho.js","assets/pako.esm-Cram60i4.js","assets/packbits-Bv1WAA2-.js","assets/lerc-4SqbgDy2.js","assets/zstd-lUMILEuL.js","assets/webimage-BJxK2_0I.js"])))=>i.map(i=>d[i]);
import{_ as F}from"./index-C_ldSz15.js";function S(r){return(e,...t)=>Ve(r,e,t)}function R(r,e){return S(de(r,e).get)}const{apply:Ve,getOwnPropertyDescriptor:de,getPrototypeOf:oe,ownKeys:Ke}=Reflect,{iterator:Y,toStringTag:ve}=Symbol,ke=Object,{create:ae,defineProperty:je}=ke,Ye=Array,Xe=Ye.prototype,xe=Xe[Y],ze=S(xe),pe=ArrayBuffer,qe=pe.prototype;R(qe,"byteLength");const ge=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:null;ge&&R(ge.prototype,"byteLength");const we=oe(Uint8Array);we.from;const P=we.prototype;P[Y];S(P.keys);S(P.values);S(P.entries);S(P.set);S(P.reverse);S(P.fill);S(P.copyWithin);S(P.sort);S(P.slice);S(P.subarray);R(P,"buffer");R(P,"byteOffset");R(P,"length");R(P,ve);const He=Uint8Array,me=Uint16Array,le=Uint32Array,$e=Float32Array,j=oe([][Y]()),Te=S(j.next),Ze=S((function*(){})().next),Je=oe(j),Qe=DataView.prototype,We=S(Qe.getUint16),ce=WeakMap,Ae=ce.prototype,De=S(Ae.get),et=S(Ae.set),Ie=new ce,tt=ae(null,{next:{value:function(){const e=De(Ie,this);return Te(e)}},[Y]:{value:function(){return this}}});function rt(r){if(r[Y]===xe&&j.next===Te)return r;const e=ae(tt);return et(Ie,e,ze(r)),e}const it=new ce,nt=ae(Je,{next:{value:function(){const e=De(it,this);return Ze(e)},writable:!0,configurable:!0}});for(const r of Ke(j))r!=="next"&&je(nt,r,de(j,r));const Se=new pe(4),st=new $e(Se),ot=new le(Se),E=new me(512),G=new He(512);for(let r=0;r<256;++r){const e=r-127;e<-24?(E[r]=0,E[r|256]=32768,G[r]=24,G[r|256]=24):e<-14?(E[r]=1024>>-e-14,E[r|256]=1024>>-e-14|32768,G[r]=-e-1,G[r|256]=-e-1):e<=15?(E[r]=e+15<<10,E[r|256]=e+15<<10|32768,G[r]=13,G[r|256]=13):e<128?(E[r]=31744,E[r|256]=64512,G[r]=24,G[r|256]=24):(E[r]=31744,E[r|256]=64512,G[r]=13,G[r|256]=13)}const fe=new le(2048);for(let r=1;r<1024;++r){let e=r<<13,t=0;for(;(e&8388608)===0;)e<<=1,t-=8388608;e&=-8388609,t+=947912704,fe[r]=e|t}for(let r=1024;r<2048;++r)fe[r]=939524096+(r-1024<<13);const L=new le(64);for(let r=1;r<31;++r)L[r]=r<<23;L[31]=1199570944;L[32]=2147483648;for(let r=33;r<63;++r)L[r]=2147483648+(r-32<<23);L[63]=3347054592;const be=new me(64);for(let r=1;r<64;++r)r!==32&&(be[r]=1024);function at(r){const e=r>>10;return ot[0]=fe[be[e]+(r&1023)]+L[e],st[0]}function Pe(r,e,...t){return at(We(r,e,...rt(t)))}function te(r,e,t){const n=typeof r=="object"?r.outer:r,i=n.slice(0,n.indexOf(">")+1),s=['"',"'"];for(let a=0;a<s.length;a++){const o=s[a],l=e+"\\="+o+"([^"+o+"]*)"+o,f=new RegExp(l).exec(i);if(f)return f[1]}}function lt(r,e,t){const i=new RegExp(e).exec(r.slice(t));return i?t+i.index:-1}function re(r,e,t){const i=new RegExp(e).exec(r.slice(t));return i?t+i.index+i[0].length-1:-1}function ye(r,e){const t=new RegExp(e,"g"),n=r.match(t);return n?n.length:0}function ct(r,e,t){const n=t&&t.debug||!1,i=!(t&&typeof t.nested===!1),s=t&&t.startIndex||0;n&&console.log("[xml-utils] starting findTagByName with",e," and ",t);const a=lt(r,`<${e}[ 
>/]`,s);if(n&&console.log("[xml-utils] start:",a),a===-1)return;const o=r.slice(a+e.length);let l=re(o,"^[^<]*[ /]>",0);const c=l!==-1&&o[l-1]==="/";if(n&&console.log("[xml-utils] selfClosing:",c),c===!1)if(i){let g=0,h=1,d=0;for(;(l=re(o,"[ /]"+e+">",g))!==-1;){const y=o.substring(g,l+1);if(h+=ye(y,"<"+e+`[ 
	>]`),d+=ye(y,"</"+e+">"),d>=h)break;g=l}}else l=re(o,"[ /]"+e+">",0);const f=a+e.length+l+1;if(n&&console.log("[xml-utils] end:",f),f===-1)return;const u=r.slice(a,f);let x;return c?x=null:x=u.slice(u.indexOf(">")+1,u.lastIndexOf("<")),{inner:x,outer:u,start:a,end:f}}function ft(r,e,t){const n=[];let s=0,a;for(;a=ct(r,e,{debug:!1,startIndex:s});)s=a.start+1+e.length,n.push(a);return n}const k={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34412:"CZ_LSMINFO",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},M={};for(const r in k)k.hasOwnProperty(r)&&(M[k[r]]=parseInt(r,10));const ht=[M.BitsPerSample,M.ExtraSamples,M.SampleFormat,M.StripByteCounts,M.StripOffsets,M.StripRowCounts,M.TileByteCounts,M.TileOffsets,M.SubIFDs],ie={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},w={};for(const r in ie)ie.hasOwnProperty(r)&&(w[ie[r]]=parseInt(r,10));const O={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,CMYK:5,YCbCr:6,CIELab:8},ut={Unspecified:0},qt={AddCompression:1},Ht={None:0,Deflate:1,Zstandard:2},gt={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"};function yt(r,e){const{width:t,height:n}=r,i=new Uint8Array(t*n*3);let s;for(let a=0,o=0;a<r.length;++a,o+=3)s=256-r[a]/e*256,i[o]=s,i[o+1]=s,i[o+2]=s;return i}function dt(r,e){const{width:t,height:n}=r,i=new Uint8Array(t*n*3);let s;for(let a=0,o=0;a<r.length;++a,o+=3)s=r[a]/e*256,i[o]=s,i[o+1]=s,i[o+2]=s;return i}function xt(r,e){const{width:t,height:n}=r,i=new Uint8Array(t*n*3),s=e.length/3,a=e.length/3*2;for(let o=0,l=0;o<r.length;++o,l+=3){const c=r[o];i[l]=e[c]/65536*256,i[l+1]=e[c+s]/65536*256,i[l+2]=e[c+a]/65536*256}return i}function pt(r){const{width:e,height:t}=r,n=new Uint8Array(e*t*3);for(let i=0,s=0;i<r.length;i+=4,s+=3){const a=r[i],o=r[i+1],l=r[i+2],c=r[i+3];n[s]=255*((255-a)/256)*((255-c)/256),n[s+1]=255*((255-o)/256)*((255-c)/256),n[s+2]=255*((255-l)/256)*((255-c)/256)}return n}function wt(r){const{width:e,height:t}=r,n=new Uint8ClampedArray(e*t*3);for(let i=0,s=0;i<r.length;i+=3,s+=3){const a=r[i],o=r[i+1],l=r[i+2];n[s]=a+1.402*(l-128),n[s+1]=a-.34414*(o-128)-.71414*(l-128),n[s+2]=a+1.772*(o-128)}return n}const mt=.95047,Tt=1,At=1.08883;function Dt(r){const{width:e,height:t}=r,n=new Uint8Array(e*t*3);for(let i=0,s=0;i<r.length;i+=3,s+=3){const a=r[i+0],o=r[i+1]<<24>>24,l=r[i+2]<<24>>24;let c=(a+16)/116,f=o/500+c,u=c-l/200,x,g,h;f=mt*(f*f*f>.008856?f*f*f:(f-16/116)/7.787),c=Tt*(c*c*c>.008856?c*c*c:(c-16/116)/7.787),u=At*(u*u*u>.008856?u*u*u:(u-16/116)/7.787),x=f*3.2406+c*-1.5372+u*-.4986,g=f*-.9689+c*1.8758+u*.0415,h=f*.0557+c*-.204+u*1.057,x=x>.0031308?1.055*x**(1/2.4)-.055:12.92*x,g=g>.0031308?1.055*g**(1/2.4)-.055:12.92*g,h=h>.0031308?1.055*h**(1/2.4)-.055:12.92*h,n[s]=Math.max(0,Math.min(1,x))*255,n[s+1]=Math.max(0,Math.min(1,g))*255,n[s+2]=Math.max(0,Math.min(1,h))*255}return n}const Oe=new Map,It=new Map;function _(r,e,t=!0){Array.isArray(r)||(r=[r]),r.forEach(n=>{Oe.set(n,e),It.set(n,t)})}async function Ee(r){const e=Oe.get(r.Compression);if(!e)throw new Error(`Unknown compression method identifier: ${r.Compression}`);const t=await e();return new t(r)}_([void 0,1],()=>F(()=>import("./raw-Cnb_Ypsi.js"),__vite__mapDeps([0,1,2])).then(r=>r.default),!1);_(5,()=>F(()=>import("./lzw-DOH9cVIV.js"),__vite__mapDeps([3,1,2])).then(r=>r.default));_(6,()=>{throw new Error("old style JPEG compression is not supported.")});_(7,()=>F(()=>import("./jpeg-DWrTXVOr.js"),__vite__mapDeps([4,1,2])).then(r=>r.default));_([8,32946],()=>F(()=>import("./deflate-YOpszOho.js"),__vite__mapDeps([5,6,1,2])).then(r=>r.default));_(32773,()=>F(()=>import("./packbits-Bv1WAA2-.js"),__vite__mapDeps([7,1,2])).then(r=>r.default));_(34887,()=>F(()=>import("./lerc-4SqbgDy2.js"),__vite__mapDeps([8,6,1,2])).then(async r=>(await r.zstd.init(),r)).then(r=>r.default));_(5e4,()=>F(()=>import("./zstd-lUMILEuL.js"),__vite__mapDeps([9,1,2])).then(async r=>(await r.zstd.init(),r)).then(r=>r.default));_(50001,()=>F(()=>import("./webimage-BJxK2_0I.js"),__vite__mapDeps([10,1,2])).then(r=>r.default),!1);function J(r,e,t,n=1){return new(Object.getPrototypeOf(r)).constructor(e*t*n)}function St(r,e,t,n,i){const s=e/n,a=t/i;return r.map(o=>{const l=J(o,n,i);for(let c=0;c<i;++c){const f=Math.min(Math.round(a*c),t-1);for(let u=0;u<n;++u){const x=Math.min(Math.round(s*u),e-1),g=o[f*e+x];l[c*n+u]=g}}return l})}function C(r,e,t){return(1-t)*r+t*e}function bt(r,e,t,n,i){const s=e/n,a=t/i;return r.map(o=>{const l=J(o,n,i);for(let c=0;c<i;++c){const f=a*c,u=Math.floor(f),x=Math.min(Math.ceil(f),t-1);for(let g=0;g<n;++g){const h=s*g,d=h%1,y=Math.floor(h),m=Math.min(Math.ceil(h),e-1),p=o[u*e+y],A=o[u*e+m],D=o[x*e+y],T=o[x*e+m],I=C(C(p,A,d),C(D,T,d),f%1);l[c*n+g]=I}}return l})}function Pt(r,e,t,n,i,s="nearest"){switch(s.toLowerCase()){case"nearest":return St(r,e,t,n,i);case"bilinear":case"linear":return bt(r,e,t,n,i);default:throw new Error(`Unsupported resampling method: '${s}'`)}}function Ot(r,e,t,n,i,s){const a=e/n,o=t/i,l=J(r,n,i,s);for(let c=0;c<i;++c){const f=Math.min(Math.round(o*c),t-1);for(let u=0;u<n;++u){const x=Math.min(Math.round(a*u),e-1);for(let g=0;g<s;++g){const h=r[f*e*s+x*s+g];l[c*n*s+u*s+g]=h}}}return l}function Et(r,e,t,n,i,s){const a=e/n,o=t/i,l=J(r,n,i,s);for(let c=0;c<i;++c){const f=o*c,u=Math.floor(f),x=Math.min(Math.ceil(f),t-1);for(let g=0;g<n;++g){const h=a*g,d=h%1,y=Math.floor(h),m=Math.min(Math.ceil(h),e-1);for(let p=0;p<s;++p){const A=r[u*e*s+y*s+p],D=r[u*e*s+m*s+p],T=r[x*e*s+y*s+p],I=r[x*e*s+m*s+p],U=C(C(A,D,d),C(T,I,d),f%1);l[c*n*s+g*s+p]=U}}}return l}function Gt(r,e,t,n,i,s,a="nearest"){switch(a.toLowerCase()){case"nearest":return Ot(r,e,t,n,i,s);case"bilinear":case"linear":return Et(r,e,t,n,i,s);default:throw new Error(`Unsupported resampling method: '${a}'`)}}function Mt(r,e,t){let n=0;for(let i=e;i<t;++i)n+=r[i];return n}function ne(r,e,t){switch(r){case 1:if(e<=8)return new Uint8Array(t);if(e<=16)return new Uint16Array(t);if(e<=32)return new Uint32Array(t);break;case 2:if(e===8)return new Int8Array(t);if(e===16)return new Int16Array(t);if(e===32)return new Int32Array(t);break;case 3:switch(e){case 16:case 32:return new Float32Array(t);case 64:return new Float64Array(t)}break}throw Error("Unsupported data format/bitsPerSample")}function _t(r,e){return(r===1||r===2)&&e<=32&&e%8===0?!1:!(r===3&&(e===16||e===32||e===64))}function Ft(r,e,t,n,i,s,a){const o=new DataView(r),l=t===2?a*s:a*s*n,c=t===2?1:n,f=ne(e,i,l),u=parseInt("1".repeat(i),2);if(e===1){let x;t===1?x=n*i:x=i;let g=s*x;(g&7)!==0&&(g=g+7&-8);for(let h=0;h<a;++h){const d=h*g;for(let y=0;y<s;++y){const m=d+y*c*i;for(let p=0;p<c;++p){const A=m+p*i,D=(h*s+y)*c+p,T=Math.floor(A/8),I=A%8;if(I+i<=8)f[D]=o.getUint8(T)>>8-i-I&u;else if(I+i<=16)f[D]=o.getUint16(T)>>16-i-I&u;else if(I+i<=24){const U=o.getUint16(T)<<8|o.getUint8(T+2);f[D]=U>>24-i-I&u}else f[D]=o.getUint32(T)>>32-i-I&u}}}}return f.buffer}class Ge{constructor(e,t,n,i,s,a){this.fileDirectory=e,this.geoKeys=t,this.dataView=n,this.littleEndian=i,this.tiles=s?{}:null,this.isTiled=!e.StripOffsets;const o=e.PlanarConfiguration;if(this.planarConfiguration=typeof o>"u"?1:o,this.planarConfiguration!==1&&this.planarConfiguration!==2)throw new Error("Invalid planar configuration.");this.source=a}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return typeof this.fileDirectory.SamplesPerPixel<"u"?this.fileDirectory.SamplesPerPixel:1}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:typeof this.fileDirectory.RowsPerStrip<"u"?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBlockWidth(){return this.getTileWidth()}getBlockHeight(e){return this.isTiled||(e+1)*this.getTileHeight()<=this.getHeight()?this.getTileHeight():this.getHeight()-e*this.getTileHeight()}getBytesPerPixel(){let e=0;for(let t=0;t<this.fileDirectory.BitsPerSample.length;++t)e+=this.getSampleByteSize(t);return e}getSampleByteSize(e){if(e>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${e} is out of range.`);return Math.ceil(this.fileDirectory.BitsPerSample[e]/8)}getReaderForSample(e){const t=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1,n=this.fileDirectory.BitsPerSample[e];switch(t){case 1:if(n<=8)return DataView.prototype.getUint8;if(n<=16)return DataView.prototype.getUint16;if(n<=32)return DataView.prototype.getUint32;break;case 2:if(n<=8)return DataView.prototype.getInt8;if(n<=16)return DataView.prototype.getInt16;if(n<=32)return DataView.prototype.getInt32;break;case 3:switch(n){case 16:return function(i,s){return Pe(this,i,s)};case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}break}throw Error("Unsupported data format/bitsPerSample")}getSampleFormat(e=0){return this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1}getBitsPerSample(e=0){return this.fileDirectory.BitsPerSample[e]}getArrayForSample(e,t){const n=this.getSampleFormat(e),i=this.getBitsPerSample(e);return ne(n,i,t)}async getTileOrStrip(e,t,n,i,s){const a=Math.ceil(this.getWidth()/this.getTileWidth()),o=Math.ceil(this.getHeight()/this.getTileHeight());let l;const{tiles:c}=this;this.planarConfiguration===1?l=t*a+e:this.planarConfiguration===2&&(l=n*a*o+t*a+e);let f,u;if(this.isTiled?(f=this.fileDirectory.TileOffsets[l],u=this.fileDirectory.TileByteCounts[l]):(f=this.fileDirectory.StripOffsets[l],u=this.fileDirectory.StripByteCounts[l]),u===0){const h=this.getBlockHeight(t)*this.getTileWidth(),d=this.planarConfiguration===2?this.getSampleByteSize(n):this.getBytesPerPixel(),y=new ArrayBuffer(h*d);return this.getArrayForSample(n,y).fill(this.getGDALNoData()||0),{x:e,y:t,sample:n,data:y}}const x=(await this.source.fetch([{offset:f,length:u}],s))[0];let g;return c===null||!c[l]?(g=(async()=>{let h=await i.decode(this.fileDirectory,x);const d=this.getSampleFormat(),y=this.getBitsPerSample();return _t(d,y)&&(h=Ft(h,d,this.planarConfiguration,this.getSamplesPerPixel(),y,this.getTileWidth(),this.getBlockHeight(t))),h})(),c!==null&&(c[l]=g)):g=c[l],{x:e,y:t,sample:n,data:await g}}async _readRaster(e,t,n,i,s,a,o,l,c){const f=this.getTileWidth(),u=this.getTileHeight(),x=this.getWidth(),g=this.getHeight(),h=Math.max(Math.floor(e[0]/f),0),d=Math.min(Math.ceil(e[2]/f),Math.ceil(x/f)),y=Math.max(Math.floor(e[1]/u),0),m=Math.min(Math.ceil(e[3]/u),Math.ceil(g/u)),p=e[2]-e[0];let A=this.getBytesPerPixel();const D=[],T=[];for(let b=0;b<t.length;++b)this.planarConfiguration===1?D.push(Mt(this.fileDirectory.BitsPerSample,0,t[b])/8):D.push(0),T.push(this.getReaderForSample(t[b]));const I=[],{littleEndian:U}=this;for(let b=y;b<m;++b)for(let X=h;X<d;++X){let W;this.planarConfiguration===1&&(W=this.getTileOrStrip(X,b,0,s,c));for(let z=0;z<t.length;++z){const q=z,he=t[z];this.planarConfiguration===2&&(A=this.getSampleByteSize(he),W=this.getTileOrStrip(X,b,he,s,c));const Me=W.then(N=>{const _e=N.data,Fe=new DataView(_e),ee=this.getBlockHeight(N.y),V=N.y*u,H=N.x*f,Ue=V+ee,Be=(N.x+1)*f,Ce=T[q],Re=Math.min(ee,ee-(Ue-e[3]),g-V),Le=Math.min(f,f-(Be-e[2]),x-H);for(let K=Math.max(0,e[1]-V);K<Re;++K)for(let v=Math.max(0,e[0]-H);v<Le;++v){const Ne=(K*f+v)*A,ue=Ce.call(Fe,Ne+D[q],U);let $;i?($=(K+V-e[1])*p*t.length+(v+H-e[0])*t.length+q,n[$]=ue):($=(K+V-e[1])*p+v+H-e[0],n[q][$]=ue)}});I.push(Me)}}if(await Promise.all(I),a&&e[2]-e[0]!==a||o&&e[3]-e[1]!==o){let b;return i?b=Gt(n,e[2]-e[0],e[3]-e[1],a,o,t.length,l):b=Pt(n,e[2]-e[0],e[3]-e[1],a,o,l),b.width=a,b.height=o,b}return n.width=a||e[2]-e[0],n.height=o||e[3]-e[1],n}async readRasters({window:e,samples:t=[],interleave:n,pool:i=null,width:s,height:a,resampleMethod:o,fillValue:l,signal:c}={}){const f=e||[0,0,this.getWidth(),this.getHeight()];if(f[0]>f[2]||f[1]>f[3])throw new Error("Invalid subsets");const u=f[2]-f[0],x=f[3]-f[1],g=u*x,h=this.getSamplesPerPixel();if(!t||!t.length)for(let p=0;p<h;++p)t.push(p);else for(let p=0;p<t.length;++p)if(t[p]>=h)return Promise.reject(new RangeError(`Invalid sample index '${t[p]}'.`));let d;if(n){const p=this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,A=Math.max.apply(null,this.fileDirectory.BitsPerSample);d=ne(p,A,g*t.length),l&&d.fill(l)}else{d=[];for(let p=0;p<t.length;++p){const A=this.getArrayForSample(t[p],g);Array.isArray(l)&&p<l.length?A.fill(l[p]):l&&!Array.isArray(l)&&A.fill(l),d.push(A)}}const y=i||await Ee(this.fileDirectory);return await this._readRaster(f,t,d,n,y,s,a,o,c)}async readRGB({window:e,interleave:t=!0,pool:n=null,width:i,height:s,resampleMethod:a,enableAlpha:o=!1,signal:l}={}){const c=e||[0,0,this.getWidth(),this.getHeight()];if(c[0]>c[2]||c[1]>c[3])throw new Error("Invalid subsets");const f=this.fileDirectory.PhotometricInterpretation;if(f===O.RGB){let m=[0,1,2];if(this.fileDirectory.ExtraSamples!==ut.Unspecified&&o){m=[];for(let p=0;p<this.fileDirectory.BitsPerSample.length;p+=1)m.push(p)}return this.readRasters({window:e,interleave:t,samples:m,pool:n,width:i,height:s,resampleMethod:a,signal:l})}let u;switch(f){case O.WhiteIsZero:case O.BlackIsZero:case O.Palette:u=[0];break;case O.CMYK:u=[0,1,2,3];break;case O.YCbCr:case O.CIELab:u=[0,1,2];break;default:throw new Error("Invalid or unsupported photometric interpretation.")}const x={window:c,interleave:!0,samples:u,pool:n,width:i,height:s,resampleMethod:a,signal:l},{fileDirectory:g}=this,h=await this.readRasters(x),d=2**this.fileDirectory.BitsPerSample[0];let y;switch(f){case O.WhiteIsZero:y=yt(h,d);break;case O.BlackIsZero:y=dt(h,d);break;case O.Palette:y=xt(h,g.ColorMap);break;case O.CMYK:y=pt(h);break;case O.YCbCr:y=wt(h);break;case O.CIELab:y=Dt(h);break;default:throw new Error("Unsupported photometric interpretation.")}if(!t){const m=new Uint8Array(y.length/3),p=new Uint8Array(y.length/3),A=new Uint8Array(y.length/3);for(let D=0,T=0;D<y.length;D+=3,++T)m[T]=y[D],p[T]=y[D+1],A[T]=y[D+2];y=[m,p,A]}return y.width=h.width,y.height=h.height,y}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const e=[];for(let t=0;t<this.fileDirectory.ModelTiepoint.length;t+=6)e.push({i:this.fileDirectory.ModelTiepoint[t],j:this.fileDirectory.ModelTiepoint[t+1],k:this.fileDirectory.ModelTiepoint[t+2],x:this.fileDirectory.ModelTiepoint[t+3],y:this.fileDirectory.ModelTiepoint[t+4],z:this.fileDirectory.ModelTiepoint[t+5]});return e}getGDALMetadata(e=null){const t={};if(!this.fileDirectory.GDAL_METADATA)return null;const n=this.fileDirectory.GDAL_METADATA;let i=ft(n,"Item");e===null?i=i.filter(s=>te(s,"sample")===void 0):i=i.filter(s=>Number(te(s,"sample"))===e);for(let s=0;s<i.length;++s){const a=i[s];t[te(a,"name")]=a.inner}return t}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const e=this.fileDirectory.GDAL_NODATA;return Number(e.substring(0,e.length-1))}getOrigin(){const e=this.fileDirectory.ModelTiepoint,t=this.fileDirectory.ModelTransformation;if(e&&e.length===6)return[e[3],e[4],e[5]];if(t)return[t[3],t[7],t[11]];throw new Error("The image does not have an affine transformation.")}getResolution(e=null){const t=this.fileDirectory.ModelPixelScale,n=this.fileDirectory.ModelTransformation;if(t)return[t[0],-t[1],t[2]];if(n)return n[1]===0&&n[4]===0?[n[0],-n[5],n[10]]:[Math.sqrt(n[0]*n[0]+n[4]*n[4]),-Math.sqrt(n[1]*n[1]+n[5]*n[5]),n[10]];if(e){const[i,s,a]=e.getResolution();return[i*e.getWidth()/this.getWidth(),s*e.getHeight()/this.getHeight(),a*e.getWidth()/this.getWidth()]}throw new Error("The image does not have an affine transformation.")}pixelIsArea(){return this.geoKeys.GTRasterTypeGeoKey===1}getBoundingBox(e=!1){const t=this.getHeight(),n=this.getWidth();if(this.fileDirectory.ModelTransformation&&!e){const[i,s,a,o,l,c,f,u]=this.fileDirectory.ModelTransformation,g=[[0,0],[0,t],[n,0],[n,t]].map(([y,m])=>[o+i*y+s*m,u+l*y+c*m]),h=g.map(y=>y[0]),d=g.map(y=>y[1]);return[Math.min(...h),Math.min(...d),Math.max(...h),Math.max(...d)]}else{const i=this.getOrigin(),s=this.getResolution(),a=i[0],o=i[1],l=a+s[0]*n,c=o+s[1]*t;return[Math.min(a,l),Math.min(o,c),Math.max(a,l),Math.max(o,c)]}}}class Ut{constructor(e){this._dataView=new DataView(e)}get buffer(){return this._dataView.buffer}getUint64(e,t){const n=this.getUint32(e,t),i=this.getUint32(e+4,t);let s;if(t){if(s=n+2**32*i,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}if(s=2**32*n+i,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}getInt64(e,t){let n=0;const i=(this._dataView.getUint8(e+(t?7:0))&128)>0;let s=!0;for(let a=0;a<8;a++){let o=this._dataView.getUint8(e+(t?a:7-a));i&&(s?o!==0&&(o=~(o-1)&255,s=!1):o=~o&255),n+=o*256**a}return i&&(n=-n),n}getUint8(e,t){return this._dataView.getUint8(e,t)}getInt8(e,t){return this._dataView.getInt8(e,t)}getUint16(e,t){return this._dataView.getUint16(e,t)}getInt16(e,t){return this._dataView.getInt16(e,t)}getUint32(e,t){return this._dataView.getUint32(e,t)}getInt32(e,t){return this._dataView.getInt32(e,t)}getFloat16(e,t){return Pe(this._dataView,e,t)}getFloat32(e,t){return this._dataView.getFloat32(e,t)}getFloat64(e,t){return this._dataView.getFloat64(e,t)}}class Bt{constructor(e,t,n,i){this._dataView=new DataView(e),this._sliceOffset=t,this._littleEndian=n,this._bigTiff=i}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(e,t){return this.sliceOffset<=e&&this.sliceTop>=e+t}readUint8(e){return this._dataView.getUint8(e-this._sliceOffset,this._littleEndian)}readInt8(e){return this._dataView.getInt8(e-this._sliceOffset,this._littleEndian)}readUint16(e){return this._dataView.getUint16(e-this._sliceOffset,this._littleEndian)}readInt16(e){return this._dataView.getInt16(e-this._sliceOffset,this._littleEndian)}readUint32(e){return this._dataView.getUint32(e-this._sliceOffset,this._littleEndian)}readInt32(e){return this._dataView.getInt32(e-this._sliceOffset,this._littleEndian)}readFloat32(e){return this._dataView.getFloat32(e-this._sliceOffset,this._littleEndian)}readFloat64(e){return this._dataView.getFloat64(e-this._sliceOffset,this._littleEndian)}readUint64(e){const t=this.readUint32(e),n=this.readUint32(e+4);let i;if(this._littleEndian){if(i=t+2**32*n,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}if(i=2**32*t+n,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}readInt64(e){let t=0;const n=(this._dataView.getUint8(e+(this._littleEndian?7:0))&128)>0;let i=!0;for(let s=0;s<8;s++){let a=this._dataView.getUint8(e+(this._littleEndian?s:7-s));n&&(i?a!==0&&(a=~(a-1)&255,i=!1):a=~a&255),t+=a*256**s}return n&&(t=-t),t}readOffset(e){return this._bigTiff?this.readUint64(e):this.readUint32(e)}}class Ct{async fetch(e,t=void 0){return Promise.all(e.map(n=>this.fetchSlice(n,t)))}async fetchSlice(e){throw new Error(`fetching of slice ${e} not possible, not implemented`)}get fileSize(){return null}async close(){}}class Rt extends Ct{constructor(e){super(),this.file=e}async fetchSlice(e,t){return new Promise((n,i)=>{const s=this.file.slice(e.offset,e.offset+e.length),a=new FileReader;a.onload=o=>n(o.target.result),a.onerror=i,a.onabort=i,a.readAsArrayBuffer(s),t&&t.addEventListener("abort",()=>a.abort())})}}function Lt(r){return new Rt(r)}function Nt(r,e){let t=r.length-e,n=0;do{for(let i=e;i>0;i--)r[n+e]+=r[n],n++;t-=e}while(t>0)}function Vt(r,e,t){let n=0,i=r.length;const s=i/t;for(;i>e;){for(let o=e;o>0;--o)r[n+e]+=r[n],++n;i-=e}const a=r.slice();for(let o=0;o<s;++o)for(let l=0;l<t;++l)r[t*o+l]=a[(t-l-1)*s+o]}function Kt(r,e,t,n,i,s){if(e===1)return r;for(let l=0;l<i.length;++l){if(i[l]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(i[l]!==i[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const a=i[0]/8,o=s===2?1:i.length;for(let l=0;l<n&&!(l*o*t*a>=r.byteLength);++l){let c;if(e===2){switch(i[0]){case 8:c=new Uint8Array(r,l*o*t*a,o*t*a);break;case 16:c=new Uint16Array(r,l*o*t*a,o*t*a/2);break;case 32:c=new Uint32Array(r,l*o*t*a,o*t*a/4);break;default:throw new Error(`Predictor 2 not allowed with ${i[0]} bits per sample.`)}Nt(c,o)}else e===3&&(c=new Uint8Array(r,l*o*t*a,o*t*a),Vt(c,o,a))}return r}class vt{async decode(e,t){const n=await this.decodeBlock(t),i=e.Predictor||1;if(i!==1){const s=!e.StripOffsets,a=s?e.TileWidth:e.ImageWidth,o=s?e.TileLength:e.RowsPerStrip||e.ImageLength;return Kt(n,i,a,o,e.BitsPerSample,e.PlanarConfiguration)}return n}}function se(r){switch(r){case w.BYTE:case w.ASCII:case w.SBYTE:case w.UNDEFINED:return 1;case w.SHORT:case w.SSHORT:return 2;case w.LONG:case w.SLONG:case w.FLOAT:case w.IFD:return 4;case w.RATIONAL:case w.SRATIONAL:case w.DOUBLE:case w.LONG8:case w.SLONG8:case w.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${r}`)}}function kt(r){const e=r.GeoKeyDirectory;if(!e)return null;const t={};for(let n=4;n<=e[3]*4;n+=4){const i=gt[e[n]],s=e[n+1]?k[e[n+1]]:null,a=e[n+2],o=e[n+3];let l=null;if(!s)l=o;else{if(l=r[s],typeof l>"u"||l===null)throw new Error(`Could not get value of geoKey '${i}'.`);typeof l=="string"?l=l.substring(o,o+a-1):l.subarray&&(l=l.subarray(o,o+a),a===1&&(l=l[0]))}t[i]=l}return t}function B(r,e,t,n){let i=null,s=null;const a=se(e);switch(e){case w.BYTE:case w.ASCII:case w.UNDEFINED:i=new Uint8Array(t),s=r.readUint8;break;case w.SBYTE:i=new Int8Array(t),s=r.readInt8;break;case w.SHORT:i=new Uint16Array(t),s=r.readUint16;break;case w.SSHORT:i=new Int16Array(t),s=r.readInt16;break;case w.LONG:case w.IFD:i=new Uint32Array(t),s=r.readUint32;break;case w.SLONG:i=new Int32Array(t),s=r.readInt32;break;case w.LONG8:case w.IFD8:i=new Array(t),s=r.readUint64;break;case w.SLONG8:i=new Array(t),s=r.readInt64;break;case w.RATIONAL:i=new Uint32Array(t*2),s=r.readUint32;break;case w.SRATIONAL:i=new Int32Array(t*2),s=r.readInt32;break;case w.FLOAT:i=new Float32Array(t),s=r.readFloat32;break;case w.DOUBLE:i=new Float64Array(t),s=r.readFloat64;break;default:throw new RangeError(`Invalid field type: ${e}`)}if(e===w.RATIONAL||e===w.SRATIONAL)for(let o=0;o<t;o+=2)i[o]=s.call(r,n+o*a),i[o+1]=s.call(r,n+(o*a+4));else for(let o=0;o<t;++o)i[o]=s.call(r,n+o*a);return e===w.ASCII?new TextDecoder("utf-8").decode(i):i}class jt{constructor(e,t,n,i){this.fileDirectory=e,this.rawFileDirectory=t,this.geoKeyDirectory=n,this.nextIFDByteOffset=i}}class Z extends Error{constructor(e){super(`No image at index ${e}`),this.index=e}}class Yt{async readRasters(e={}){const{window:t,width:n,height:i}=e;let{resX:s,resY:a,bbox:o}=e;const l=await this.getImage();let c=l;const f=await this.getImageCount(),u=l.getBoundingBox();if(t&&o)throw new Error('Both "bbox" and "window" passed.');if(n||i){if(t){const[h,d]=l.getOrigin(),[y,m]=l.getResolution();o=[h+t[0]*y,d+t[1]*m,h+t[2]*y,d+t[3]*m]}const g=o||u;if(n){if(s)throw new Error("Both width and resX passed");s=(g[2]-g[0])/n}if(i){if(a)throw new Error("Both width and resY passed");a=(g[3]-g[1])/i}}if(s||a){const g=[];for(let h=0;h<f;++h){const d=await this.getImage(h),{SubfileType:y,NewSubfileType:m}=d.fileDirectory;(h===0||y===2||m&1)&&g.push(d)}g.sort((h,d)=>h.getWidth()-d.getWidth());for(let h=0;h<g.length;++h){const d=g[h],y=(u[2]-u[0])/d.getWidth(),m=(u[3]-u[1])/d.getHeight();if(c=d,s&&s>y||a&&a>m)break}}let x=t;if(o){const[g,h]=l.getOrigin(),[d,y]=c.getResolution(l);x=[Math.round((o[0]-g)/d),Math.round((o[1]-h)/y),Math.round((o[2]-g)/d),Math.round((o[3]-h)/y)],x=[Math.min(x[0],x[2]),Math.min(x[1],x[3]),Math.max(x[0],x[2]),Math.max(x[1],x[3])]}return c.readRasters({...e,window:x})}}class Q extends Yt{constructor(e,t,n,i,s={}){super(),this.source=e,this.littleEndian=t,this.bigTiff=n,this.firstIFDOffset=i,this.cache=s.cache||!1,this.ifdRequests=[],this.ghostValues=null}async getSlice(e,t){const n=this.bigTiff?4048:1024;return new Bt((await this.source.fetch([{offset:e,length:typeof t<"u"?t:n}]))[0],e,this.littleEndian,this.bigTiff)}async parseFileDirectoryAt(e){const t=this.bigTiff?20:12,n=this.bigTiff?8:2;let i=await this.getSlice(e);const s=this.bigTiff?i.readUint64(e):i.readUint16(e),a=s*t+(this.bigTiff?16:6);i.covers(e,a)||(i=await this.getSlice(e,a));const o={},l=new Map;let c=e+(this.bigTiff?8:2);for(let x=0;x<s;c+=t,++x){const g=i.readUint16(c),h=i.readUint16(c+2),d=this.bigTiff?i.readUint64(c+4):i.readUint32(c+4);let y,m;const p=se(h),A=c+(this.bigTiff?12:8);if(p*d<=(this.bigTiff?8:4))y=B(i,h,d,A);else{const T=i.readOffset(A),I=se(h)*d;if(i.covers(T,I))y=B(i,h,d,T);else{const U=await this.getSlice(T,I);y=B(U,h,d,T)}}d===1&&ht.indexOf(g)===-1&&!(h===w.RATIONAL||h===w.SRATIONAL)?m=y[0]:m=y;const D=k[g];D&&(o[D]=m),l.set(g,m)}const f=kt(o),u=i.readOffset(e+n+t*s);return new jt(o,l,f,u)}async requestIFD(e){if(this.ifdRequests[e])return this.ifdRequests[e];if(e===0)return this.ifdRequests[e]=this.parseFileDirectoryAt(this.firstIFDOffset),this.ifdRequests[e];if(!this.ifdRequests[e-1])try{this.ifdRequests[e-1]=this.requestIFD(e-1)}catch(t){throw t instanceof Z?new Z(e):t}return this.ifdRequests[e]=(async()=>{const t=await this.ifdRequests[e-1];if(t.nextIFDByteOffset===0)throw new Z(e);return this.parseFileDirectoryAt(t.nextIFDByteOffset)})(),this.ifdRequests[e]}async getImage(e=0){const t=await this.requestIFD(e);return new Ge(t.fileDirectory,t.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){let e=0,t=!0;for(;t;)try{await this.requestIFD(e),++e}catch(n){if(n instanceof Z)t=!1;else throw n}return e}async getGhostValues(){const e=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const t="GDAL_STRUCTURAL_METADATA_SIZE=",n=t.length+100;let i=await this.getSlice(e,n);if(t===B(i,w.ASCII,t.length,e)){const a=B(i,w.ASCII,n,e).split(`
`)[0],o=Number(a.split("=")[1].split(" ")[0])+a.length;o>n&&(i=await this.getSlice(e,o));const l=B(i,w.ASCII,o,e);this.ghostValues={},l.split(`
`).filter(c=>c.length>0).map(c=>c.split("=")).forEach(([c,f])=>{this.ghostValues[c]=f})}return this.ghostValues}static async fromSource(e,t,n){const i=(await e.fetch([{offset:0,length:1024}],n))[0],s=new Ut(i),a=s.getUint16(0,0);let o;if(a===18761)o=!0;else if(a===19789)o=!1;else throw new TypeError("Invalid byte order value.");const l=s.getUint16(2,o);let c;if(l===42)c=!1;else if(l===43){if(c=!0,s.getUint16(4,o)!==8)throw new Error("Unsupported offset byte-size.")}else throw new TypeError("Invalid magic number.");const f=c?s.getUint64(8,o):s.getUint32(4,o);return new Q(e,o,c,f,t)}close(){return typeof this.source.close=="function"?this.source.close():!1}}async function Xt(r,e){return Q.fromSource(Lt(r),e)}const $t=Object.freeze(Object.defineProperty({__proto__:null,BaseDecoder:vt,GeoTIFF:Q,GeoTIFFImage:Ge,addDecoder:_,fromBlob:Xt,getDecoder:Ee},Symbol.toStringTag,{value:"Module"}));export{vt as B,qt as L,Ht as a,$t as g};
